{"posts":[{"title":"莫队","content":" 并非是我们选择了命运，而是命运选择了我们。 我们今天来讲一个所有人都知道的算法。 众所周知，莫队算法是由莫涛大神提出的，一种玄学骗分的区间操作算法。以简短的框架、简单的板子（大雾）和优秀的复杂度闻名于世。然而，莫队算法的题目都是较高的难度评级 （指NOI/NOI+/CTSC或暂未评级）。 前置知识们 分块 STL的sort的用法（包括但不限于手写cmp函数） 基础的卡常技巧（包括但不限于#pragma GCC optimize） *倍增/树剖 求LCA（树上莫队所需） ∗数值离散化（用于应付很多题目） 莫队算法是什么 莫队算法（mo's algorithm）一般分为两类，一是莫队维护区间答案，二是维护区间内的数据结构。当然也有树上莫队，带修改莫队、二维莫队等等。 然而这个算法到底是干嘛的呢？我们先来瞎看一道题：P1972（是道蓝题，没想到吧），你可以点进链接查看题目，也可以留下，在这里看题。 例题 题目描述 HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。 有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。 输入格式 一行一个正整数 nnn，表示项链长度。 第二行nnn个正整数 aia_iai​ ，表示项链中第 iii个贝壳的种类。 第三行一个整数 mmm，表示 HH 询问的个数。 接下来 mmm 行，每行两个整数 l,rl,rl,r，表示询问的区间。 输出格式 输出mmm行，每行一个整数，依次表示询问对应的答案。 输入输出样例 输入样例#1： 6 1 2 3 4 3 5 3 1 2 3 5 2 6 输出样例#1： 2 2 4 说明/提示 【数据范围】 对于 20%20\\%20% 的数据，1⩽n,m⩽50001\\leqslant n,m\\leqslant 50001⩽n,m⩽5000； 对于 40%40\\%40% 的数据，1⩽n,m⩽1051\\leqslant n,m\\leqslant 10^51⩽n,m⩽105； 对于 60%60\\%60% 的数据，1⩽n,m⩽5×1051\\leqslant n,m\\leqslant 5\\times 10^51⩽n,m⩽5×105； 对于 100%100\\%100% 的数据，1⩽n,m,ai⩽1061\\leqslant n,m,a_i \\leqslant 10^61⩽n,m,ai​⩽106，1⩽l⩽r⩽n1\\leqslant l \\leqslant r \\leqslant n1⩽l⩽r⩽n。 本题可能需要较快的读入方式，最大数据点读入数据约 20MB。 だが，这道题卡了莫队，所以我们要看一道数据弱化版SP3267 DQUERY - D-query（数据弱化版居然是道紫题，没想到吧） 讲解 题目到手，我们开始分析本题的算法。这题最简单做法无非暴力——用一个cnt数组记录每个数值出现的次数，再暴力枚举lll到rrr统计次数，最后再扫一遍cnt数组，统计cnt不为零的数值个数，输出答案即可。设最大数值为sss，那么这样做的复杂度为O(m(n+s))∼O(n2)O(m(n+s))\\sim O(n^2)O(m(n+s))∼O(n2)，对于本题实在跑不起。 我们就在想，可不可以来那么亿点点优化。于是，两个优化如下： 每一次枚举到的数值num，增加出现次数的时候判断cnt[num]是否等于0，若是，则加一，反之，则为-1。这样，我们就优化掉了一个O(ms)O(ms)O(ms)，但是，还是跑不起啊！ 我们在搞2个指针，l和r，每次询问，我们不直接枚举，而是移动他们到询问的区间。直到他们所形成的闭区间与询问区间重合。然后统计答案时，我们就在指针处加减cnt，这样就可以快速统计了！ 如果有不理解的，可以去看看这篇博客，写得超棒！ 我们就写一下代码吧： int aa[maxn], cnt[maxn], l = 1, r = 0, now = 0; void add(int pos) { if (!cnt[aa[pos]]) ++now; ++cnt[aa[pos]]; } void del(int pos) { --cnt[aa[pos]]; if (!cnt[aa[pos]]) --now; } void work() { for (int i = 1; i &lt;= q; ++i) { int ql, qr; scanf(&quot;%d%d&quot;, &amp;ql, &amp;qr); while (l &lt; ql) del(l++); while (l &gt; ql) add(--l); while (r &lt; qr) add(++r); while (r &gt; qr) del(r--); printf(&quot;%d\\n&quot;, now); } } 刚刚的优化2，在普通的情况下表现很好，但是如果区间是形如Q1 Q3 Q5 Q7 ... Q6 Q4 Q2的，那么优2就基本上蔫了。我们就来剪枝吧！ 莫队算法的基础实现 我们可以大致把莫队算法理解为一种超级暴力的算法，只不过，他的剪枝及其精妙，使得其达到了极其优秀的时间复杂度。 接下来，我们需要引入一些计算。我们定义∑ai=a1+⋯+an\\sum a_i=a_1+\\cdots+a_n∑ai​=a1​+⋯+an​，即aia_iai​的总和。 预处理 莫队算法优化的核心是分块和排序。我们将大小为nnn的序列分成n\\sqrt{n}n​个块。从111至n\\sqrt{n}n​排序，然后根据这个对查询区间进行排序。 一种方法是把查询区间按照左端点所在块的序号排个序，如果左端点所在块相同，再按右端点排序。排完序后我们再进行左右指针跳来跳去的操作，虽然看似没多大用，但带来的优化实际上极大。 我们来乱搞算一下他的时间复杂度 首先，是区间排序，用sort跑一遍，就行了。平均时间复杂度为O(nlog⁡n)O(n\\log n)O(nlogn)。 接下来，是左指针的移动，设每个块iii中分布有xix_ixi​个左端点，由于莫队的添加删除操作的复杂度为O(1)O(1)O(1)，那么处理块iii的最坏时间复杂度为O(xin)O(x_i\\sqrt{n})O(xi​n​)，跨越整个块的时间复杂度为O(n)O(\\sqrt{n})O(n​)。最坏跨越nnn次，总复杂度为O(∑xin+nn)=O(nn)O(\\sum x_i\\sqrt{n}+n\\sqrt{n})=O(n\\sqrt{n})O(∑xi​n​+nn​)=O(nn​) ","link":"https://david-h-devs.github.io/post/mo-dui/"},{"title":"二叉树","content":"（由于Gitalk暂时配置很麻烦，所以我等他配置好之后我在用吧！） 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 一棵深度为k，且有2k−12^k-12k−1个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。具有n个结点的完全二叉树的深度为floor(log⁡2n)+1\\mathrm{floor}(\\log 2n)+1floor(log2n)+1。深度为k的完全二叉树，至少有2k−12^{k-1}2k−1个叶子结点，至多有2k−12^k-12k−1个结点。 二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态： 空二叉树； 只有一个根节点的二叉树； 只有左子树； 只有右子树； 完全二叉树。 注意：二叉树不是树 我们来简要的写写二叉树的代码（例如去重搜索）： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10; struct Node { int val, lc, rc, w; } T[N]; int n, cnt = 1, a[N]; void ins(int o, int v) { if (!(T[o].val)) { T[o].val = v; T[o].w++; return; } if (T[o].val == v) { T[o].w++; return; } if (v &lt; T[o].val) { if (!(T[o].lc)) T[o].lc = ++cnt; ins(T[o].lc, v); } if (v &gt; T[o].val) { if (!T[o].rc) T[o].rc = ++cnt; ins(T[o].rc, v); } } void dfs(int o) { if (!T[o].val) return; if (T[o].lc) dfs(T[o].lc); printf(&quot;%d &quot;, T[o].val); if (T[o].rc) dfs(T[o].rc); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i); for (int i = 1; i &lt;= n; i++) { ins(1, a[i]); } dfs(1); return 0; } ","link":"https://david-h-devs.github.io/post/xian-duan-shu/"},{"title":"新建博客撒花","content":"在3月7日（确切的来说几天前就建好了，但这次是正式版），我的博客建成了！ 这要感谢搭建Gridea的工程师们与我的朋友LewisLi（这是他的博客）。 总而言之，我的小博客总算建好了！以后还会陆续加一些东西，比如2D小人这类的qwq。 都要加油啊！ ","link":"https://david-h-devs.github.io/post/xin-jian-bo-ke-sa-hua/"}]}