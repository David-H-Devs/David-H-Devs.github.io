{"posts":[{"title":"P2482 [SDOI2010]猪国杀（试着看看题）","content":"我们先抄一下题（惯例）。 题目描述 游戏背景 《猪国杀》是一种多猪牌类回合制游戏，一共有 333 种角色：主猪，忠猪，反猪。每局游戏主猪有且只有 111 只，忠猪和反猪可以有多只，每只猪扮演 111 种角色。 游戏目的 主猪 / MP\\texttt{MP}MP：自己存活的情况下消灭所有的反猪。 忠猪 / ZP\\texttt{ZP}ZP：不惜一切保护主猪，胜利条件与主猪相同。 反猪 / \\texttt{AP}：杀死主猪。 游戏过程 游戏开始时，每个玩家手里都会有 4 张牌，且体力上限和初始体力都是 4 。 开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从 1 , 2, 3 \\ldots n , 1 \\ldot的顺序）依次行动。 每个玩家自己的回合可以分为 2 个阶段： 摸牌阶段：从牌堆顶部摸 2 张牌，依次放到手牌的最右边； 出牌阶段：你可以使用任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。当然，要满足如下规则： 如果没有猪哥连弩，每个出牌阶段只能使用 1 次「杀」来攻击； 任何牌被使用后被弃置（武器是装备上）；被弃置的牌以后都不能再用，即与游戏无关。 各种牌介绍 每张手牌用 1 个字母表示，字母代表牌的种类。 基本牌 『桃 / P\\texttt{P}P』在自己的回合内，如果自己的体力值不等于体力上限，那么使用 11 个桃可以为自己补充 11 点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为 00 或者更低，那么也可以使用。 『杀 / K\\texttt{K}K』在自己的回合内，对攻击范围内除自己以外的 11 名角色使用。如果没有被『闪』抵消，则造成 11 点伤害。无论有无武器，杀的攻击范围都是 11。 『闪 / D\\texttt{D}D』当你受到杀的攻击时，可以弃置 11 张闪来抵消杀的效果。 锦囊牌 『决斗 / F\\texttt{F}F』出牌阶段，对除自己以外任意 11 名角色使用，由目标角色先开始，自己和目标角色轮流弃置 11 张杀，首先没有杀可弃的一方受到 11 点伤害，另一方视为此伤害的来源。 『南猪入侵 / N\\texttt{N}N』出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置 11 张杀，否则受到 11 点伤害。 『万箭齐发 / W\\texttt{W}W』和南猪入侵类似，不过要弃置的不是杀而是闪。 『无懈可击 / J\\texttt{J}J』在目标锦囊生效前抵消其效果。每次有 1 张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对 1 个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。 装备牌 『猪哥连弩 / Z\\texttt{Z}Z』武器，攻击范围 1 ，出牌阶段你可以使用任意张杀; 同一时刻最多只能装 1 把武器；如果先前已经有了 1 把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器。 特殊事件及概念解释 伤害来源：杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪，决斗的伤害来源如上； 距离：两只猪的距离定义为沿着逆时针方向间隔的猪数 +1 。即初始时 1 和 2 的距离为 1，但是 2 和 1 的距离就是 n-1 。注意一个角色的死亡会导致一些猪距离的改变； 玩家死亡：如果该玩家的体力降到 0 或者更低，并且自己手中没有足够的桃使得自己的体力值回到 1 ，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置； 奖励与惩罚：反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸 33 张牌。忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置。 注意： 一旦达成胜利条件，游戏立刻结束，因此即使会摸 33 张牌或者还有牌可以用也不用执行了。 现在，我们已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏，你需要做的就是告诉小猪 iPig 最后的结果。 几种行为 献殷勤：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意； 表敌意：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤； 跳忠：即通过行动表示自己是忠猪。跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意； 跳反：即通过行动表示自己是反猪。跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤。 **注意：**忠猪不会跳反，反猪也不会跳忠；不管是忠猪还是反猪，能够跳必然跳。 行动准则 共性 每个角色如果手里有桃且生命值未满，那么必然吃掉； 有南猪入侵、万箭齐发、必然使用；有装备必然装上； 受到杀时，有闪必然弃置； 响应南猪入侵或者万箭齐发时候，有杀 / 闪必然弃置； 不会对未表明身份的猪献殷勤（包括自己）。 特性（bug） 主猪： 主猪会认为「没有跳身份，且用南猪入侵 / 万箭齐发对自己造成伤害的猪」是类反猪（没伤害到不算，注意类反猪并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪； 对于每种表敌意的方式，对逆时针方向能够执行到的第一只类反猪或者已跳反猪表；如果没有，那么就不表敌意；决斗时会不遗余力弃置杀；如果能对已经跳忠的猪或自己献殷勤，那么一定献；如果能够对已经跳反的猪表敌意，那么一定表。 忠猪： 对于每种表敌意的方式，对「逆时针方向能够执行到的第一只已经跳反的猪」表，如果没有，那么就不表敌意；决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀；如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献。 反猪： 对于每种表敌意的方式，如果有机会则对主猪表，否则，对「逆时针方向能够执行到的第一只已经跳忠的猪」表，如果没有，那么就不表敌意；决斗时会不遗余力弃置杀；如果有机会对已经跳反的猪献殷勤，那么一定献。 限于 iPig 只会用 P++ 语言写 A + B，他请你用 Pigcal (Pascal)、P (C) 或 P++ (C++) 语言来帮他预测最后的结果。 输入格式 输入文件第一行包含两个正整数 n(2⩽n⩽10)n(2 \\leqslant n \\leqslant 10)n(2⩽n⩽10)和 m(m⩽2000)m(m \\leqslant 2000)m(m⩽2000)，分别代表玩家数和牌堆中牌的数量。数据保证牌的数量够用。 接下来 nnn 行，每行 555 个字符串，依次表示对第 iii 只猪的角色和初始 444 张手牌描述。编号为 111 的肯定是主猪。 再接下来一行，一共 mmm 个字符串，按照从牌堆顶部到牌堆底部的顺序描述每张牌。 注意： 所有的相邻的两个字符串都严格用 111 个空格隔开，行尾没有多余空格。 输出格式 输出数据第一行包含一个字符串代表游戏结果。如果是主猪胜利，那么输出MP\\texttt{MP}MP，否则输出FP\\texttt{FP}FP。数据保证游戏总会结束。 接下来 n 行，第 i 行是对第 i 只猪的手牌描述（注意只需要输出手牌），按照手牌从左往右的顺序输出，相邻两张牌用 1 个空格隔开，行末尾没有多余空格。如果这只猪已阵亡，那么只要输出DEAD\\texttt{DEAD}DEAD即可。 注意： 如果要输出手牌而没有手牌的话，那么只需输出 1 个空行。 输入输出样例 ","link":"https://david-h-devs.github.io/post/p2482-sdoi2010zhu-guo-sha-shi-zhao-kan-kan-ti/"},{"title":"各种模板","content":"快读模板 int read() { int a = 0, b = 1; char c = getchar(); while (c &gt;= '9' || c &lt;= '0') { if (c == '-') b = -1; c = getchar(); } while (c &lt;= '9' &amp;&amp; c &gt;= '0') { a = a * 10 + c - '0'; c = getchar(); } return a * b; } 快写模板 void printi(int x) { if(x / 10) printi(x / 10); putchar(x % 10 + '0'); } ","link":"https://david-h-devs.github.io/post/ge-chong-mo-ban/"},{"title":"莫队","content":" 并非是我们选择了命运，而是命运选择了我们。 我们今天来讲一个所有人都知道的算法。 众所周知，莫队算法是由莫涛大神提出的，一种玄学骗分的区间操作算法。以简短的框架、简单的板子（大雾）和优秀的复杂度闻名于世。然而，莫队算法的题目都是较高的难度评级 （指NOI/NOI+/CTSC或暂未评级）。 前置知识们 分块 STL的sort的用法（包括但不限于手写cmp函数） 基础的卡常技巧（包括但不限于#pragma GCC optimize） *倍增/树剖 求LCA（树上莫队所需） ∗数值离散化（用于应付很多题目） 莫队算法是什么 莫队算法（mo's algorithm）一般分为两类，一是莫队维护区间答案，二是维护区间内的数据结构。当然也有树上莫队，带修改莫队、二维莫队等等。 然而这个算法到底是干嘛的呢？我们先来瞎看一道题：P1972（是道蓝题，没想到吧），你可以点进链接查看题目，也可以留下，在这里看题。 例题 题目描述 HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。 有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。 输入格式 一行一个正整数 nnn，表示项链长度。 第二行nnn个正整数 aia_iai​ ，表示项链中第 iii个贝壳的种类。 第三行一个整数 mmm，表示 HH 询问的个数。 接下来 mmm 行，每行两个整数 l,rl,rl,r，表示询问的区间。 输出格式 输出mmm行，每行一个整数，依次表示询问对应的答案。 输入输出样例 输入样例#1： 6 1 2 3 4 3 5 3 1 2 3 5 2 6 输出样例#1： 2 2 4 说明/提示 【数据范围】 对于 20%20\\%20% 的数据，1⩽n,m⩽50001\\leqslant n,m\\leqslant 50001⩽n,m⩽5000； 对于 40%40\\%40% 的数据，1⩽n,m⩽1051\\leqslant n,m\\leqslant 10^51⩽n,m⩽105； 对于 60%60\\%60% 的数据，1⩽n,m⩽5×1051\\leqslant n,m\\leqslant 5\\times 10^51⩽n,m⩽5×105； 对于 100%100\\%100% 的数据，1⩽n,m,ai⩽1061\\leqslant n,m,a_i \\leqslant 10^61⩽n,m,ai​⩽106，1⩽l⩽r⩽n1\\leqslant l \\leqslant r \\leqslant n1⩽l⩽r⩽n。 本题可能需要较快的读入方式，最大数据点读入数据约 20MB。 だが，这道题卡了莫队，所以我们要看一道数据弱化版SP3267 DQUERY - D-query（数据弱化版居然是道紫题，没想到吧） 讲解 题目到手，我们开始分析本题的算法。这题最简单做法无非暴力——用一个cnt数组记录每个数值出现的次数，再暴力枚举lll到rrr统计次数，最后再扫一遍cnt数组，统计cnt不为零的数值个数，输出答案即可。设最大数值为sss，那么这样做的复杂度为O(m(n+s))∼O(n2)O(m(n+s))\\sim O(n^2)O(m(n+s))∼O(n2)，对于本题实在跑不起。 我们就在想，可不可以来那么亿点点优化。于是，两个优化如下： 每一次枚举到的数值num，增加出现次数的时候判断cnt[num]是否等于0，若是，则加一，反之，则为-1。这样，我们就优化掉了一个O(ms)O(ms)O(ms)，但是，还是跑不起啊！ 我们在搞2个指针，l和r，每次询问，我们不直接枚举，而是移动他们到询问的区间。直到他们所形成的闭区间与询问区间重合。然后统计答案时，我们就在指针处加减cnt，这样就可以快速统计了！ 如果有不理解的，可以去看看这篇博客，写得超棒！ 我们就写一下代码吧：（这个博客的作者太蒟了，来自原博客） int aa[maxn], cnt[maxn], l = 1, r = 0, now = 0; void add(int pos) { if (!cnt[aa[pos]]) ++now; ++cnt[aa[pos]]; } void del(int pos) { --cnt[aa[pos]]; if (!cnt[aa[pos]]) --now; } void work() { for (int i = 1; i &lt;= q; ++i) { int ql, qr; scanf(&quot;%d%d&quot;, &amp;ql, &amp;qr); while (l &lt; ql) del(l++); while (l &gt; ql) add(--l); while (r &lt; qr) add(++r); while (r &gt; qr) del(r--); printf(&quot;%d\\n&quot;, now); } } 刚刚的优化2，在普通的情况下表现很好，但是如果区间是形如Q1 Q3 Q5 Q7 ... Q6 Q4 Q2的，那么优2就基本上蔫了。我们就来剪枝吧！ 莫队算法的基础实现 我们可以大致把莫队算法理解为一种超级暴力的算法，只不过，他的剪枝及其精妙，使得其达到了极其优秀的时间复杂度。 接下来，我们需要引入一些计算。我们定义∑ai=a1+⋯+an\\sum a_i=a_1+\\cdots+a_n∑ai​=a1​+⋯+an​，即aia_iai​的总和。 预处理 莫队算法优化的核心是分块和排序。我们将大小为nnn的序列分成n\\sqrt{n}n​个块。从111至n\\sqrt{n}n​排序，然后根据这个对查询区间进行排序。 一种方法是把查询区间按照左端点所在块的序号排个序，如果左端点所在块相同，再按右端点排序。排完序后我们再进行左右指针跳来跳去的操作，虽然看似没多大用，但带来的优化实际上极大。 我们来乱搞算一下他的时间复杂度 首先，是区间排序，用sort跑一遍，就行了。平均时间复杂度为O(nlog⁡n)O(n\\log n)O(nlogn)。 接下来，是左指针的移动，设每个块iii中分布有xix_ixi​个左端点，由于莫队的添加删除操作的复杂度为O(1)O(1)O(1)，那么处理块iii的最坏时间复杂度为O(xin)O(x_i\\sqrt{n})O(xi​n​)，跨越整个块的时间复杂度为O(n)O(\\sqrt{n})O(n​)。最坏跨越nnn次，总复杂度为O(∑xin+nn)=O(nn)O(\\sum x_i\\sqrt{n}+n\\sqrt{n})=O(n\\sqrt{n})O(∑xi​n​+nn​)=O(nn​) 再然后，是右指针的移动，设每个块 iii 中分布有xix_ixi​个左端点，由于左端点同块的区间右端点有序，那么对于这xix_ixi​个区间，右端点最坏只需总共O(n)O(n)O(n)的时间跳（最坏需跳完整个序列），总共n\\sqrt{n}n​个块，总复杂度O(nn)O(n\\sqrt{n})O(nn​)； 然后求一下和，在nnn足够大的时候，我们在nnn\\sqrt{n}nn​下可以忽略nlog⁡nn\\log nnlogn，故总复杂度为O(nn)O(n\\sqrt{n})O(nn​)。 对于一些不需要写大常数莫队而数据范围巨大的题目来说（如例题），整整一个根号的提升意味着运行时间质的飞跃。 不过经过排序打乱原序之后，这个算法就变成了典型的离线算法，而且这种算法不支持修改。如果遇到强制在线的题目，还要另寻他法。 来自原博客的参考代码： int cmp(query a, query b) { return belong[a.l] == belong[b.l] ? a.r &lt; b.r : belong[a.l] &lt; belong[b.l]; } 定策略 （来自原博客） 一般来说，我们只要找到指针移动一位以后，统计数据与当前数据的差值，找出规律（可以用数学方法或打表），然后每次移动时用这个规律更新就行啦qwq。至于例题……在后面会有哒qwq！ 码代码与查错 （来自原博客） 莫队代码不长（或者说是很短），但很容易写错一些细节。比如自加自减运算符的优先级问题、排序关键字问题、分块大小与sqrt精度问题、还有某些题目中用到的离散化的锅。所以每次码完莫队都别先测样例（甚至可以先不编译），先静态查错一阵，真的可以帮助你大大减少错误的发生。 我们来讲一下玄学卡常技巧 1.喜闻乐见的#pragma GCC optimize(2) 可以用实践证明，开了O2的莫队简直跑得飞快，连1e6都能无压力跑过，甚至可以比不开O2的版本快上4~5倍乃至更多。然而部分OI比赛中O2是禁止的，如果不禁O2的话，那还是开着吧qwq 实在不行，就optimize(3)（大雾 2.特别玄学的奇偶性排序 （来自原博客） 这个是最玄学的……无力吐槽 这个和莫队的主算法有异曲同工之妙……看起来卵用都没有，实际上可以帮你每个点平均优化200ms（可怕） 主要操作：把查询区间的排序函数 int cmp(query a, query b) { return belong[a.l] == belong[b.l] ? a.r &lt; b.r : belong[a.l] &lt; belong[b.l]; } 二话不说，直接删掉，换成 int cmp(query a, query b) { return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r); } 也就是说，对于左端点在同一奇数块的区间，右端点按升序排列，反之降序。这个东西也是看着没用，但实际效果显著。 它的主要原理便是右指针跳完奇数块往回跳时在同一个方向能顺路把偶数块跳完，然后跳完这个偶数块又能顺带把下一个奇数块跳完。理论上主算法运行时间减半，实际情况有所偏差。（不过能优化得很爽就对了） 3、移动指针的常数压缩 （仍然是来自原博客） 我们可以根据运算优先级的知识，把这个： void add(int pos) { if(!cnt[aa[pos]]) ++now; ++cnt[aa[pos]]; } void del(int pos) { --cnt[aa[pos]]; if(!cnt[aa[pos]]) --now; } 和这个： while(l &lt; ql) del(l++); while(l &gt; ql) add(--l); while(r &lt; qr) add(++r); while(r &gt; qr) del(r--); 硬生生压缩成这个： while(l &lt; ql) now -= !--cnt[aa[l++]]; while(l &gt; ql) now += !cnt[aa[--l]]++; while(r &lt; qr) now += !cnt[aa[++r]]++; while(r &gt; qr) now -= !--cnt[aa[r--]]; 能优化将近200ms（怎么又是这个数字） 而且这个优化看上去满满的不好搞，但实际上很有用。不过用它来优化千万要建立在熟练的基础上，不然会大大增强调试难度，不如不用。 4.手写快读、快输 （还是来自原博客） 大多数莫队题的输入输出量还是很大的……I/O优化与否，运行时间差异也很大。而且值得注意的是莫队经典题中基本没有输入输出负数的情况，不考虑负数又能优化一点小小的常数。 我们来写（抄）一下代码吧！（依然是来自原博客） #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; using namespace std; #define maxn 1010000 #define maxb 1010 int aa[maxn], cnt[maxn], belong[maxn]; int n, m, size, bnum, now, ans[maxn]; struct query { int l, r, id; } q[maxn]; int cmp(query a, query b) { return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r); } #define isdigit(x) ((x) &gt;= '0' &amp;&amp; (x) &lt;= '9') int read() { int res = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar(); return res; } void printi(int x) { if(x / 10) printi(x / 10); putchar(x % 10 + '0'); } int main() { scanf(&quot;%d&quot;, &amp;n); size = sqrt(n); bnum = ceil((double)n / size); for(int i = 1; i &lt;= bnum; ++i) for(int j = (i - 1) * size + 1; j &lt;= i * size; ++j) { belong[j] = i; } for(int i = 1; i &lt;= n; ++i) aa[i] = read(); m = read(); for(int i = 1; i &lt;= m; ++i) { q[i].l = read(), q[i].r = read(); q[i].id = i; } sort(q + 1, q + m + 1, cmp); int l = 1, r = 0; for(int i = 1; i &lt;= m; ++i) { int ql = q[i].l, qr = q[i].r; while(l &lt; ql) now -= !--cnt[aa[l++]]; while(l &gt; ql) now += !cnt[aa[--l]]++; while(r &lt; qr) now += !cnt[aa[++r]]++; while(r &gt; qr) now -= !--cnt[aa[r--]]; ans[q[i].id] = now; } for(int i = 1; i &lt;= m; ++i) printi(ans[i]), putchar('\\n'); return 0; } ","link":"https://david-h-devs.github.io/post/mo-dui/"},{"title":"二叉树","content":"（由于Gitalk暂时配置很麻烦，所以我等他配置好之后我在用吧！） 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 一棵深度为k，且有2k−12^k-12k−1个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。具有n个结点的完全二叉树的深度为floor(log⁡2n)+1\\mathrm{floor}(\\log 2n)+1floor(log2n)+1。深度为k的完全二叉树，至少有2k−12^{k-1}2k−1个叶子结点，至多有2k−12^k-12k−1个结点。 二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态： 空二叉树； 只有一个根节点的二叉树； 只有左子树； 只有右子树； 完全二叉树。 注意：二叉树不是树 我们来简要的写写二叉树的代码（例如去重搜索）： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10; struct Node { int val, lc, rc, w; } T[N]; int n, cnt = 1, a[N]; void ins(int o, int v) { if (!(T[o].val)) { T[o].val = v; T[o].w++; return; } if (T[o].val == v) { T[o].w++; return; } if (v &lt; T[o].val) { if (!(T[o].lc)) T[o].lc = ++cnt; ins(T[o].lc, v); } if (v &gt; T[o].val) { if (!T[o].rc) T[o].rc = ++cnt; ins(T[o].rc, v); } } void dfs(int o) { if (!T[o].val) return; if (T[o].lc) dfs(T[o].lc); printf(&quot;%d &quot;, T[o].val); if (T[o].rc) dfs(T[o].rc); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i); for (int i = 1; i &lt;= n; i++) { ins(1, a[i]); } dfs(1); return 0; } ","link":"https://david-h-devs.github.io/post/xian-duan-shu/"},{"title":"新建博客撒花","content":"在3月7日（确切的来说几天前就建好了，但这次是正式版），我的博客建成了！ 这要感谢搭建Gridea的工程师们与我的朋友LewisLi（这是他的博客）。 总而言之，我的小博客总算建好了！以后还会陆续加一些东西，比如2D小人这类的qwq。 都要加油啊！ 中国总是被他们最勇敢的人保护得很好。 ","link":"https://david-h-devs.github.io/post/xin-jian-bo-ke-sa-hua/"}]}