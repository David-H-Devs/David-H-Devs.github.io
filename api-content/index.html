{"posts":[{"title":"莫队","content":"我们今天来讲一个所有人都知道的算法。 众所周知，莫队算法是由莫涛大神提出的，一种玄学骗分的区间操作算法。以简短的框架、简单的板子（大雾）和优秀的复杂度闻名于世。然而，莫队算法的题目都是较高的难度评级 （指NOI/NOI+/CTSC或暂未评级）。 前置知识们 分块 STL的sort的用法（包括但不限于手写cmp函数） 基础的卡常技巧（包括但不限于#pragma GCC optimize） ","link":"https://david-h-devs.github.io/post/mo-dui/"},{"title":"二叉树","content":"（由于Gitalk暂时配置很麻烦，所以我等他配置好之后我在用吧！） 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 一棵深度为k，且有2k−12^k-12k−1个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。具有n个结点的完全二叉树的深度为floor(log⁡2n)+1\\mathrm{floor}(\\log 2n)+1floor(log2n)+1。深度为k的完全二叉树，至少有2k−12^{k-1}2k−1个叶子结点，至多有2k−12^k-12k−1个结点。 二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态： 空二叉树； 只有一个根节点的二叉树； 只有左子树； 只有右子树； 完全二叉树。 注意：二叉树不是树 我们来简要的写写二叉树的代码（例如去重搜索）： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10; struct Node { int val, lc, rc, w; } T[N]; int n, cnt = 1, a[N]; void ins(int o, int v) { if (!(T[o].val)) { T[o].val = v; T[o].w++; return; } if (T[o].val == v) { T[o].w++; return; } if (v &lt; T[o].val) { if (!(T[o].lc)) T[o].lc = ++cnt; ins(T[o].lc, v); } if (v &gt; T[o].val) { if (!T[o].rc) T[o].rc = ++cnt; ins(T[o].rc, v); } } void dfs(int o) { if (!T[o].val) return; if (T[o].lc) dfs(T[o].lc); printf(&quot;%d &quot;, T[o].val); if (T[o].rc) dfs(T[o].rc); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i); for (int i = 1; i &lt;= n; i++) { ins(1, a[i]); } dfs(1); return 0; } ","link":"https://david-h-devs.github.io/post/xian-duan-shu/"},{"title":"新建博客撒花","content":"在3月7日（确切的来说几天前就建好了，但这次是正式版），我的博客建成了！ 这要感谢搭建Gridea的工程师们与我的朋友LewisLi（这是他的博客）。 总而言之，我的小博客总算建好了！以后还会陆续加一些东西，比如2D小人这类的qwq。 都要加油啊！ ","link":"https://david-h-devs.github.io/post/xin-jian-bo-ke-sa-hua/"}]}