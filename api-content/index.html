{"posts":[{"title":"初一集训练习（第三周） - 题解","content":"这次好像多了1题，我们来看看。 题目A 题目描述 有一个这样的问题，有一颗存在NNN个节点的树，同时默认111号节点是根，每个节点都有一个集合，这些集合可以看做是一个数组，刚开始默认集合都是空的。随着访问节点的推进，父亲的集合数字会被儿子节点继承。 我们在访问每个节点的时候，一开始会继承父亲的集合数字，接着同时会有两个操作——插入与删除数字。 输入格式 输入格式 第一行输入数字NNN表示树有多少个节点（节点数字默认从111到NNN） 第二行输入N−1N-1N−1个整数，第iii个数字的值表示第i+1i+1i+1个节点的父亲是谁 接下来NNN行表示访问第iii个节点同时进行的操作，具体每一行第一个数字KKK表示这个节点有多少个操作，同一行接下来KKK个整数，正数XXX的表示往这个节点集合插入一个数字XXX，如果重复则不插入；如果是一个负数XXX，则把∣X∣|X|∣X∣这个数字从已有的集合中删掉。 输出格式 输出NNN行，每行表示第iii个节点里面有多少个数字。 样例 样例1 Input: 1 5 1 -2 3 -4 5 Output: 3 样例2 Input: 5 1 1 5 2 3 1 -2 5 2 -2 3 2 -5 3 2 2 3 2 2 3 Output: 2 3 2 4 4 说明/提示 【数据说明】 1⩽N⩽2001\\leqslant N\\leqslant 2001⩽N⩽200 1⩽∑K⩽2001\\leqslant \\sum K\\leqslant 2001⩽∑K⩽200 −100000⩽X⩽100000-100000\\leqslant X\\leqslant 100000−100000⩽X⩽100000 且 X≠0X\\ne 0X​=0 题解 到手，我们先分析一下题目。 有一颗存在NNN个节点的树，同时默认111号节点是根 嗯，很好，看起来跟图有关。 每个节点都有一个集合，这些集合可以看做是一个数组，刚开始默认集合都是空的。 嗯，看起来可以用vector或者二维数组做。 一开始会继承父亲的集合数字。 嗯，那就暴力！每次父亲节点弄了一个，他的儿子节点就更新！ 然后，就可以完美的TLE编程了！ ","link":"https://david-h-devs.github.io/post/chu-yi-ji-xun-lian-xi-di-san-zhou-ti-jie/"},{"title":"OI梗们","content":"即得易见平凡，仿照上例显然。留作习题答案略，读者自证不难。 反之亦然同理，推论自然成立，略去过程QED，由上可知证毕。 三年oi一场空，不开long long见祖宗。 三年oi一场空，三道原题见祖宗。 三年oi一场空，D1爆炸见祖宗。 三年oi一场空，交错文件见祖宗 十年oi一场空，不打对拍见祖宗。 十年oi一场空，数组开小见祖宗。 十年oi一场空，一场初赛AFO。 十年oi一场空，D1T3见祖宗。 两天六题三棵树，DP要写高精度。 NOIP提高难度 = 一天的普及难度 + 一天的省选难度 NOIP = noi plus 只有两种时间复杂度：O(跑的出)与O(跑不出)。 我会写六种自动机：WA 自动机、TLE 自动机、MLE 自动机、RE 自动机、CE 自动机还有UKE 自动机。 骗分过样例，暴力出奇迹 爆搜挂着机，打表出省一 N 方过百万，暴力踩标算 肥修赛大象，只是代码短 稻花香里说丰年，听取WA声一片。 浔阳DP无音乐，终岁不闻AC声。 天若有情天亦老，人间CE是沧桑。 日啖RE三百颗，不辞长做岭南人。 暴力出奇迹，骗分过样例。 打表是数学，DP看运气。 穷举TLE，递推UKE。 模拟MLE，贪心还CE。 想要骗到分，一定有方法。 图论背模板，数论背公式。 动规背方程，高精背代码。 如果都没背，干脆输样例。 数组大十倍，RE变AC 只要胆子大，十亿开得下 ","link":"https://david-h-devs.github.io/post/oi-geng-men/"},{"title":"月赛讲评 #1","content":"从这个月开始，每个月都会有1-2次月赛（在蒟蒻欢乐小窝里面的团队赛） 本博客将会置顶7天后撤销置顶。 我们来讲一下【GJR-001】2020 年 DH 3 月蒟蒻欢乐水题赛吧！ 题目A 题目背景 小明学会了好多数据结构，他想要加强求逆序对的题目、数据并缩短时间。 题目描述 我们对于一个nnn项的数列{ai}\\{a_i\\}{ai​}，如果对于这个数列内的任何不同的两项axa_xax​，aya_yay​满足x&lt;yx&lt;yx&lt;y且ax⩾aya_x\\geqslant a_yax​⩾ay​，则称这是这个数列的一个逆序。 输入格式 第一行，一个正整数nnn。 第二行，共nnn个数，每个数保证在int范围内。 输出格式 共一行，一个正整数kkk，保证kkk在int范围内 样例 样例输入#1 3 3 2 1 样例输出#2 1 AC代码 #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; int n, m, c[40005] = {0}, a[40005] = {0}, b[40005] = {0}; inline void Add(register int x) { for (; x &lt;= n; x += (x &amp; -x)) c[x]++; } inline int Sum(register int x) { register int s = 0; for (; x &gt; 0; x -= (x &amp; -x)) s += c[x]; return s; } bool cmp1(const int &amp;x, const int &amp;y) { return b[x] &gt; b[y]; } int main() { freopen(&quot;3.in&quot;, &quot;r&quot;, stdin); freopen(&quot;3.out&quot;, &quot;w&quot;, stdout); int ans = 0; scanf(&quot;%d&quot;, &amp;n); for (register int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;b[i]); a[i] = i; } sort(a + 1, a + n + 1, cmp1); for (register int i = 1; i &lt;= n; i++) { Add(a[i]); ans += Sum(a[i] - 1); } printf(&quot;%d&quot;, ans); return 0; } 题目B 题目背景 小A搞出来了一种函数： A(x)={x2−1,x⩽1ln⁡(x−1),1&lt;x⩽2A(x)=\\left\\{\\begin{aligned}&amp; x^2-1, x \\leqslant 1 \\\\ &amp; \\ln (x-1),1&lt;x\\leqslant2\\end{aligned}\\right. A(x)={​x2−1,x⩽1ln(x−1),1&lt;x⩽2​ 但他不会算。（来自出题人的吐槽：事真多） 题目描述 我们在本题中，把函数f(x)f(x)f(x)的定义域记作Df\\mathbf{D}_{f}Df​，把函数f(x)f(x)f(x)的值域记作Rf\\mathbf{R}_{f}Rf​。同时，把以e\\mathrm{e}e为底的对数记作ln⁡\\lnln，以101010为底的对数记作log⁡\\loglog。 对于小A所列的函数，其定义域为DA=(−∞,2]\\mathbf{D}_{A}=(-\\infty, 2]DA​=(−∞,2]。求值域，我们一般都是通过画图解决，如A(x)A(x)A(x)的函数图像如下图所示： 可以看到，图像在x=1x=1x=1处有一个跳跃，且这个跳跃后的点与原先的点不重合，我们就称这样的函数不连续。同时，我们发现比较困难算的ln⁡(x−1)\\ln (x-1)ln(x−1)仅需求出最小值即可，我们发现，在x=1x=1x=1时，函数没有定义，所以这里的最小值可以看做是−∞-\\infty−∞。不难算出，RA=(−∞,+∞)\\mathbf{R}_{A}=(-\\infty,+\\infty)RA​=(−∞,+∞)，即RA=R\\mathbf{R}_{A}=\\mathbf{R}RA​=R。（不要问我为什么这么巧，我瞎选的两个函数，我也没想到） 我们定义一种新运算，f′(x)f&#x27;(x)f′(x)，其定义如下：（f(x)f(x)f(x)为一个连续的函数） f′(x)=lim⁡x0→xf(x0)−f(x)x0−xf&#x27;(x)=\\lim\\limits_{x_0\\to x}\\frac{f(x_0)-f(x)}{x_0-x} f′(x)=x0​→xlim​x0​−xf(x0​)−f(x)​ 我们可以把他记作dfdx(x)\\dfrac{\\mathrm{d}f}{\\mathrm{d}x}(x)dxdf​(x)或者dfdx\\dfrac{\\mathrm{d}f}{\\mathrm{d}x}dxdf​。 基于这个新运算，我们再来定义一个：∫\\int∫，它的定义是 ∫f′(x)dx=f(x)\\int f&#x27;(x)\\mathrm{d}x=f(x) ∫f′(x)dx=f(x) 即上面的新运算的逆运算。 同时，我们还有一个： ∫abf′(x)dx=f(b)−f(a)\\int_a^b f&#x27;(x)\\mathrm{d}x=f(b)-f(a) ∫ab​f′(x)dx=f(b)−f(a) 这两个式子中，dx\\mathrm{d}xdx并没有实际意义（其仅仅表明这里的变量是xxx），所以在输入数据中不会给出。 有了以上知识，我们来做这道题。 输入格式 第一行，一个正整数nnn，表示接下来会有nnn次询问。 接下来的nnn行，每行有至少111个正整数qqq和一个函数f(x)f(x)f(x)。 q=1q=1q=1时，后面会有111个函数f(x)f(x)f(x)，让你计算f′(x)f&#x27;(x)f′(x)； q=2q=2q=2时，后面会有111个函数f′(x)f&#x27;(x)f′(x)，让你计算f(x)f(x)f(x)； q=3q=3q=3时，后面会有111个函数f′(x)f&#x27;(x)f′(x)，和两个数字aaa、bbb，让你计算∫abf′(x)\\int_a^b f&#x27;(x)∫ab​f′(x)。 输出格式 对于每一次操作，输出111个数或函数，表示答案。 如果答案后面带有常数，忽略掉常数。如果答案形如1x\\dfrac{1}{x}x1​，则直接输出1/x即可。 答案不用约分！ 输入输出样例 输入#1 2 1 x^2 2 2x 输入#2 2x x^2 提示与说明 下面是一些常用新运算表： f(x)f(x)f(x) f′(x)f&#x27;(x)f′(x) x2x^2x2 2x2x2x ln⁡x\\ln xlnx 1x\\dfrac{1}{x}x1​ log⁡ax\\log_a xloga​x 1aln⁡x\\dfrac{1}{a\\ln x}alnx1​ 保证输入的f(x)f(x)f(x)或者f′(x)f&#x27;(x)f′(x)都从上面选，只有可能是kkk倍或多个函数累加，若累加，输出的结果是该几个函数累加过后的答案。 【数据范围】 1⩽q⩽31\\leqslant q\\leqslant 31⩽q⩽3，aaa，b⩽3×105b\\leqslant 3\\times 10^5b⩽3×105，n⩽3×103n\\leqslant 3\\times 10^3n⩽3×103 【样例说明】 第一个是想让我们求f(x)=x2f(x)=x^2f(x)=x2的f′(x)f&#x27;(x)f′(x)，查表，可以得到f(x)=2xf(x)=2xf(x)=2x； 同理，第二个也是这样。 如果有乘方出现，则把底数写在前，指数写在后，中间用^连接。 同时，如果有分数出现，且分子（分母）为算式，则用括号括起来，例如：110ln⁡x\\dfrac{1}{10\\ln x}10lnx1​应写作1/(10ln x) AC代码： 此题我还没有较优的AC方法，而且评测机可能抽风了，故希望有人能投递一下QAQ。 题目C 题目背景 小A又想到了一个数列{ai}\\{a_i\\}{ai​}，他的递推公式是ai=3ai−1+4ai−2a_i=3a_{i-1}+4a_{i-2}ai​=3ai−1​+4ai−2​。 可是他想知道他的通项公式。 题目描述 一般来说，对于二阶线性递归数列ai+2=pai+1+qia_{i+2}=pa_{i+1}+q_iai+2​=pai+1​+qi​，我们把方程x2=px+qx^2=px+qx2=px+q称为这个数列的特征方程。假设其两根为x1x_1x1​，x2x_2x2​，则我们不难发现： 当x1≠x2x_1\\neq x_2x1​​=x2​时，数列通项公式为xn=Ax1n+Bx2nx_n=Ax_1^n+Bx_2^nxn​=Ax1n​+Bx2n​； 若x1=x2x_1=x_2x1​=x2​，则数列通项公式为an=(An+B)x1na_n=(An+B)x_1^nan​=(An+B)x1n​。 其中AAA，BBB为常数，由a1a_1a1​，a2a_2a2​决定。 输入格式 共111行，444个数，分别是ppp，qqq，a1a_1a1​，a2a_2a2​。 输出格式 共111行，444个数，分别是AAA，BBB，x1x_1x1​，x2x_2x2​。 输入输出样例 输入#1 2 3 3 6 输入#2 0.75 -0.75 3 -1 提示与说明 【数据范围】 p,q,a1,a2,A,B,x1,x2∈[0,103]p,q,a_1,a_2,A,B,x_1,x_2\\in [0,10^3]p,q,a1​,a2​,A,B,x1​,x2​∈[0,103]，同时，如果有小数，保留到小数点后222位。 AC代码： 此题我还没有较优的AC方法，而且评测机可能抽风了，故希望有人能投递一下QAQ。 居然没有人AC...... ","link":"https://david-h-devs.github.io/post/yue-sai-jiang-ping-1/"},{"title":"目标（想要做的和想要学的）","content":"想要做的 建一个网站（例如在WordPress上自己弄一个带live2d的网站） 做猪国杀 等 想要学的 数学 平衡树 线段树 主席树 等 ","link":"https://david-h-devs.github.io/post/mu-biao-xiang-yao-zuo-de-he-xiang-yao-xue-de/"},{"title":"拉格朗日插值公式","content":" 任给定FFF中(2n+2)(2n+2)(2n+2)个数x1x_1x1​，x2x_2x2​，…，xn+1x_{n+1}xn+1​，y1y_1y1​，y2y_2y2​，…，yn+1y_{n+1}yn+1​，其中x1x_1x1​，x2x_2x2​，…，xn+1x_{n+1}xn+1​互不相同，则存在唯一的次数不超过nnn的多项式Pn(x)P_n(x)Pn​(x)，满足Pn(xi)=yi(i=1，2，…，n+1)P_n(x_i)=y_i(i=1，2，…，n+1)Pn​(xi​)=yi​(i=1，2，…，n+1)，这里： Pn(x)=yi∏i=2n+1(x−xi)∏i=2n+1(x1−xi)P_n(x)=y_i\\dfrac{\\prod\\limits_{i=2}^{n+1}(x-x_i)}{\\prod\\limits_{i=2}^{n+1}(x_1-x_i)} Pn​(x)=yi​i=2∏n+1​(x1​−xi​)i=2∏n+1​(x−xi​)​ 叫做拉格朗日插值公式。 公式的几何解释是：存在唯一的次数不超过nnn的抛物线 通过平面上的给出的(n+1)(n+1)(n+1)个点M1(x1，y1)M_1(x_1，y_1)M1​(x1​，y1​)，M2(x2，y2)M_2(x_2，y_2)M2​(x2​，y2​)，…，Mn+1(xn+1，yn+1)M_{n+1}(x_{n+1}，y_{n+1})Mn+1​(xn+1​，yn+1​)。 特别地，如对于自变数的两个值，给出了线性函数的(n=1)对应值，这线性函数就被确定。从几何方面说，直线由其两点确定，即： y=y1x−x2x1−x2+y2x−x1x2−x1y=y_1\\dfrac{x-x_2}{x_1-x_2}+y_2\\dfrac{x-x_1}{x_2-x_1} y=y1​x1​−x2​x−x2​​+y2​x2​−x1​x−x1​​ ","link":"https://david-h-devs.github.io/post/la-ge-lang-ri-cha-zhi-gong-shi/"},{"title":"MC跑酷术语","content":"最近好像入MC跑酷，但没有时间，所以就只能整理出一份术语表来看看了qwq 名称 释义 特殊用途（具体解释） neo 旋转跳 bc 脚到头顶方块的距离 常用于顶头跳 bm 助跑距离 b 远，需要跳跃的距离 一般远的单位会被省略 +n 目的地比你高几格（n高） -n 目的地比你低几格（n低） ×n 目的地斜方向几格 即在x方向偏移几格 hh head hitter，即顶头跳 X/Z 朝向x轴或者z轴 用于旋转跳 n2n（或n To n） 朝向x轴或者z轴 用于旋转跳 ","link":"https://david-h-devs.github.io/post/mc-pao-ku-zhu-yu/"},{"title":"P2482 [SDOI2010]猪国杀（试着做做）","content":"我们先抄一下题（惯例）。 题目描述 游戏背景 《猪国杀》是一种多猪牌类回合制游戏，一共有 333 种角色：主猪，忠猪，反猪。每局游戏主猪有且只有 111 只，忠猪和反猪可以有多只，每只猪扮演 111 种角色。 游戏目的 主猪 / MP\\texttt{MP}MP：自己存活的情况下消灭所有的反猪。 忠猪 / ZP\\texttt{ZP}ZP：不惜一切保护主猪，胜利条件与主猪相同。 反猪 / FP\\texttt{FP}FP：杀死主猪。 游戏过程 游戏开始时，每个玩家手里都会有 4 张牌，且体力上限和初始体力都是 4 。 开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从 1,2,3⋯n,1⋯1 , 2, 3 \\cdots n , 1 \\cdots1,2,3⋯n,1⋯ 的顺序）依次行动。 每个玩家自己的回合可以分为 2 个阶段： 摸牌阶段：从牌堆顶部摸 2 张牌，依次放到手牌的最右边； 出牌阶段：你可以使用任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。当然，要满足如下规则： 如果没有猪哥连弩，每个出牌阶段只能使用 1 次「杀」来攻击； 任何牌被使用后被弃置（武器是装备上）；被弃置的牌以后都不能再用，即与游戏无关。 各种牌介绍 每张手牌用 1 个字母表示，字母代表牌的种类。 基本牌 『桃 / P\\texttt{P}P』在自己的回合内，如果自己的体力值不等于体力上限，那么使用 11 个桃可以为自己补充 11 点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为 00 或者更低，那么也可以使用。 『杀 / K\\texttt{K}K』在自己的回合内，对攻击范围内除自己以外的 11 名角色使用。如果没有被『闪』抵消，则造成 11 点伤害。无论有无武器，杀的攻击范围都是 11。 『闪 / D\\texttt{D}D』当你受到杀的攻击时，可以弃置 11 张闪来抵消杀的效果。 锦囊牌 『决斗 / F\\texttt{F}F』出牌阶段，对除自己以外任意 11 名角色使用，由目标角色先开始，自己和目标角色轮流弃置 11 张杀，首先没有杀可弃的一方受到 11 点伤害，另一方视为此伤害的来源。 『南猪入侵 / N\\texttt{N}N』出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置 11 张杀，否则受到 11 点伤害。 『万箭齐发 / W\\texttt{W}W』和南猪入侵类似，不过要弃置的不是杀而是闪。 『无懈可击 / J\\texttt{J}J』在目标锦囊生效前抵消其效果。每次有 1 张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对 1 个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。 装备牌 『猪哥连弩 / Z\\texttt{Z}Z』武器，攻击范围 1 ，出牌阶段你可以使用任意张杀; 同一时刻最多只能装 1 把武器；如果先前已经有了 1 把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器。 特殊事件及概念解释 伤害来源：杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪，决斗的伤害来源如上； 距离：两只猪的距离定义为沿着逆时针方向间隔的猪数 +1 。即初始时 1 和 2 的距离为 1，但是 2 和 1 的距离就是 n-1 。注意一个角色的死亡会导致一些猪距离的改变； 玩家死亡：如果该玩家的体力降到 0 或者更低，并且自己手中没有足够的桃使得自己的体力值回到 1 ，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置； 奖励与惩罚：反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸 3 张牌。忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置。 注意： 一旦达成胜利条件，游戏立刻结束，因此即使会摸 3 张牌或者还有牌可以用也不用执行了。 现在，我们已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏，你需要做的就是告诉小猪 iPig 最后的结果。 几种行为 献殷勤：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意； 表敌意：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤； 跳忠：即通过行动表示自己是忠猪。跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意； 跳反：即通过行动表示自己是反猪。跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤。 注意： 忠猪不会跳反，反猪也不会跳忠；不管是忠猪还是反猪，能够跳必然跳。 行动准则 共性 每个角色如果手里有桃且生命值未满，那么必然吃掉； 有南猪入侵、万箭齐发、必然使用；有装备必然装上； 受到杀时，有闪必然弃置； 响应南猪入侵或者万箭齐发时候，有杀 / 闪必然弃置； 不会对未表明身份的猪献殷勤（包括自己）。 特性（bug） 主猪： 主猪会认为「没有跳身份，且用南猪入侵 / 万箭齐发对自己造成伤害的猪」是类反猪（没伤害到不算，注意类反猪并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪； 对于每种表敌意的方式，对逆时针方向能够执行到的第一只类反猪或者已跳反猪表；如果没有，那么就不表敌意；决斗时会不遗余力弃置杀；如果能对已经跳忠的猪或自己献殷勤，那么一定献；如果能够对已经跳反的猪表敌意，那么一定表。 忠猪： 对于每种表敌意的方式，对「逆时针方向能够执行到的第一只已经跳反的猪」表，如果没有，那么就不表敌意；决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀；如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献。 反猪： 对于每种表敌意的方式，如果有机会则对主猪表，否则，对「逆时针方向能够执行到的第一只已经跳忠的猪」表，如果没有，那么就不表敌意；决斗时会不遗余力弃置杀；如果有机会对已经跳反的猪献殷勤，那么一定献。 限于 iPig 只会用 P++ 语言写 A + B，他请你用 Pigcal (Pascal)、P (C) 或 P++ (C++) 语言来帮他预测最后的结果。 输入格式 输入文件第一行包含两个正整数 n(2⩽n⩽10)n(2 \\leqslant n \\leqslant 10)n(2⩽n⩽10)和 m(m⩽2000)m(m \\leqslant 2000)m(m⩽2000)，分别代表玩家数和牌堆中牌的数量。数据保证牌的数量够用。 接下来 nnn 行，每行 555 个字符串，依次表示对第 iii 只猪的角色和初始 444 张手牌描述。编号为 111 的肯定是主猪。 再接下来一行，一共 mmm 个字符串，按照从牌堆顶部到牌堆底部的顺序描述每张牌。 注意： 所有的相邻的两个字符串都严格用 111 个空格隔开，行尾没有多余空格。 输出格式 输出数据第一行包含一个字符串代表游戏结果。如果是主猪胜利，那么输出MP\\texttt{MP}MP，否则输出FP\\texttt{FP}FP。数据保证游戏总会结束。 接下来 n 行，第 i 行是对第 i 只猪的手牌描述（注意只需要输出手牌），按照手牌从左往右的顺序输出，相邻两张牌用 1 个空格隔开，行末尾没有多余空格。如果这只猪已阵亡，那么只要输出DEAD\\texttt{DEAD}DEAD即可。 注意： 如果要输出手牌而没有手牌的话，那么只需输出 1 个空行。 输入输出样例 输入#1 3 10 MP D D F F ZP N N N D FP J J J J F F D D J J F F K D 输出#1 FP DEAD DEAD J J J J J J D 说明/提示 样例解释 第一回合： 主猪没有目标可以表敌意； 接下来忠猪使用了 3 张南猪入侵，主猪掉了 3 点体力，并认为该角色为类反猪，3 号角色尽管手里有无懈可击，但是因为自己未表明身份，所以同样不能对自己用，乖乖掉 3 点体力； 下一回合： 反猪无牌可出； 接下来主猪对着类反猪爆发，使用 4 张决斗，忠猪死亡，结果主猪弃掉所有牌； 下来反猪摸到 1 张杀直接杀死主猪获胜。 子任务 一共 20 组测试数据，每个点 5 分。 10%10\\%10% 的数据没有锦囊牌，另外 20%20\\%20% 的数据没有无懈可击。 自己试着想想 我们先来理一下思路： 首先，我们明确他有几种牌：『杀』、『闪』、『桃』 ","link":"https://david-h-devs.github.io/post/p2482-sdoi2010zhu-guo-sha-shi-zhao-kan-kan-ti/"},{"title":"各种模板","content":"快读模板 int read() { int a = 0, b = 1; char c = getchar(); while (c &gt;= '9' || c &lt;= '0') { if (c == '-') b = -1; c = getchar(); } while (c &lt;= '9' &amp;&amp; c &gt;= '0') { a = a * 10 + c - '0'; c = getchar(); } return a * b; } 快写模板 void printi(int x) { if (x / 10) printi(x / 10); putchar(x % 10 + '0'); } ","link":"https://david-h-devs.github.io/post/ge-chong-mo-ban/"},{"title":"莫队","content":" 并非是我们选择了命运，而是命运选择了我们。 我们今天来讲一个所有人都知道的算法。 众所周知，莫队算法是由莫涛大神提出的，一种玄学骗分的区间操作算法。以简短的框架、简单的板子（大雾）和优秀的复杂度闻名于世。然而，莫队算法的题目都是较高的难度评级 （指NOI/NOI+/CTSC或暂未评级）。 前置知识们 分块 STL的sort的用法（包括但不限于手写cmp函数） 基础的卡常技巧（包括但不限于#pragma GCC optimize） *倍增/树剖 求LCA（树上莫队所需） ∗数值离散化（用于应付很多题目） 莫队算法是什么 莫队算法（mo's algorithm）一般分为两类，一是莫队维护区间答案，二是维护区间内的数据结构。当然也有树上莫队，带修改莫队、二维莫队等等。 然而这个算法到底是干嘛的呢？我们先来瞎看一道题：P1972（是道蓝题，没想到吧），你可以点进链接查看题目，也可以留下，在这里看题。 例题 题目描述 HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。 有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。 输入格式 一行一个正整数 nnn，表示项链长度。 第二行nnn个正整数 aia_iai​ ，表示项链中第 iii个贝壳的种类。 第三行一个整数 mmm，表示 HH 询问的个数。 接下来 mmm 行，每行两个整数 l,rl,rl,r，表示询问的区间。 输出格式 输出mmm行，每行一个整数，依次表示询问对应的答案。 输入输出样例 输入样例#1： 6 1 2 3 4 3 5 3 1 2 3 5 2 6 输出样例#1： 2 2 4 说明/提示 【数据范围】 对于 20%20\\%20% 的数据，1⩽n,m⩽50001\\leqslant n,m\\leqslant 50001⩽n,m⩽5000； 对于 40%40\\%40% 的数据，1⩽n,m⩽1051\\leqslant n,m\\leqslant 10^51⩽n,m⩽105； 对于 60%60\\%60% 的数据，1⩽n,m⩽5×1051\\leqslant n,m\\leqslant 5\\times 10^51⩽n,m⩽5×105； 对于 100%100\\%100% 的数据，1⩽n,m,ai⩽1061\\leqslant n,m,a_i \\leqslant 10^61⩽n,m,ai​⩽106，1⩽l⩽r⩽n1\\leqslant l \\leqslant r \\leqslant n1⩽l⩽r⩽n。 本题可能需要较快的读入方式，最大数据点读入数据约 20MB。 だが，这道题卡了莫队，所以我们要看一道数据弱化版SP3267 DQUERY - D-query（数据弱化版居然是道紫题，没想到吧） 讲解 题目到手，我们开始分析本题的算法。这题最简单做法无非暴力——用一个cnt数组记录每个数值出现的次数，再暴力枚举lll到rrr统计次数，最后再扫一遍cnt数组，统计cnt不为零的数值个数，输出答案即可。设最大数值为sss，那么这样做的复杂度为O(m(n+s))∼O(n2)O(m(n+s))\\sim O(n^2)O(m(n+s))∼O(n2)，对于本题实在跑不起。 我们就在想，可不可以来那么亿点点优化。于是，两个优化如下： 每一次枚举到的数值num，增加出现次数的时候判断cnt[num]是否等于0，若是，则加一，反之，则为-1。这样，我们就优化掉了一个O(ms)O(ms)O(ms)，但是，还是跑不起啊！ 我们在搞2个指针，l和r，每次询问，我们不直接枚举，而是移动他们到询问的区间。直到他们所形成的闭区间与询问区间重合。然后统计答案时，我们就在指针处加减cnt，这样就可以快速统计了！ 如果有不理解的，可以去看看这篇博客，写得超棒！ 我们就写一下代码吧：（这个博客的作者太蒟了，来自原博客） int aa[maxn], cnt[maxn], l = 1, r = 0, now = 0; void add(int pos) { if (!cnt[aa[pos]]) ++now; ++cnt[aa[pos]]; } void del(int pos) { --cnt[aa[pos]]; if (!cnt[aa[pos]]) --now; } void work() { for (int i = 1; i &lt;= q; ++i) { int ql, qr; scanf(&quot;%d%d&quot;, &amp;ql, &amp;qr); while (l &lt; ql) del(l++); while (l &gt; ql) add(--l); while (r &lt; qr) add(++r); while (r &gt; qr) del(r--); printf(&quot;%d\\n&quot;, now); } } 刚刚的优化2，在普通的情况下表现很好，但是如果区间是形如Q1 Q3 Q5 Q7 ... Q6 Q4 Q2的，那么优2就基本上蔫了。我们就来剪枝吧！ 莫队算法的基础实现 我们可以大致把莫队算法理解为一种超级暴力的算法，只不过，他的剪枝及其精妙，使得其达到了极其优秀的时间复杂度。 接下来，我们需要引入一些计算。我们定义∑ai=a1+⋯+an\\sum a_i=a_1+\\cdots+a_n∑ai​=a1​+⋯+an​，即aia_iai​的总和。 预处理 莫队算法优化的核心是分块和排序。我们将大小为nnn的序列分成n\\sqrt{n}n​个块。从111至n\\sqrt{n}n​排序，然后根据这个对查询区间进行排序。 一种方法是把查询区间按照左端点所在块的序号排个序，如果左端点所在块相同，再按右端点排序。排完序后我们再进行左右指针跳来跳去的操作，虽然看似没多大用，但带来的优化实际上极大。 我们来乱搞算一下他的时间复杂度 首先，是区间排序，用sort跑一遍，就行了。平均时间复杂度为O(nlog⁡n)O(n\\log n)O(nlogn)。 接下来，是左指针的移动，设每个块iii中分布有xix_ixi​个左端点，由于莫队的添加删除操作的复杂度为O(1)O(1)O(1)，那么处理块iii的最坏时间复杂度为O(xin)O(x_i\\sqrt{n})O(xi​n​)，跨越整个块的时间复杂度为O(n)O(\\sqrt{n})O(n​)。最坏跨越nnn次，总复杂度为O(∑xin+nn)=O(nn)O(\\sum x_i\\sqrt{n}+n\\sqrt{n})=O(n\\sqrt{n})O(∑xi​n​+nn​)=O(nn​) 再然后，是右指针的移动，设每个块 iii 中分布有xix_ixi​个左端点，由于左端点同块的区间右端点有序，那么对于这xix_ixi​个区间，右端点最坏只需总共O(n)O(n)O(n)的时间跳（最坏需跳完整个序列），总共n\\sqrt{n}n​个块，总复杂度O(nn)O(n\\sqrt{n})O(nn​)； 然后求一下和，在nnn足够大的时候，我们在nnn\\sqrt{n}nn​下可以忽略nlog⁡nn\\log nnlogn，故总复杂度为O(nn)O(n\\sqrt{n})O(nn​)。 对于一些不需要写大常数莫队而数据范围巨大的题目来说（如例题），整整一个根号的提升意味着运行时间质的飞跃。 不过经过排序打乱原序之后，这个算法就变成了典型的离线算法，而且这种算法不支持修改。如果遇到强制在线的题目，还要另寻他法。 来自原博客的参考代码： int cmp(query a, query b) { return belong[a.l] == belong[b.l] ? a.r &lt; b.r : belong[a.l] &lt; belong[b.l]; } 定策略 （来自原博客） 一般来说，我们只要找到指针移动一位以后，统计数据与当前数据的差值，找出规律（可以用数学方法或打表），然后每次移动时用这个规律更新就行啦qwq。至于例题……在后面会有哒qwq！ 码代码与查错 （来自原博客） 莫队代码不长（或者说是很短），但很容易写错一些细节。比如自加自减运算符的优先级问题、排序关键字问题、分块大小与sqrt精度问题、还有某些题目中用到的离散化的锅。所以每次码完莫队都别先测样例（甚至可以先不编译），先静态查错一阵，真的可以帮助你大大减少错误的发生。 我们来讲一下玄学卡常技巧 1.喜闻乐见的#pragma GCC optimize(2) 可以用实践证明，开了O2的莫队简直跑得飞快，连1e6都能无压力跑过，甚至可以比不开O2的版本快上4~5倍乃至更多。然而部分OI比赛中O2是禁止的，如果不禁O2的话，那还是开着吧qwq 实在不行，就optimize(3)（大雾 2.特别玄学的奇偶性排序 （来自原博客） 这个是最玄学的……无力吐槽 这个和莫队的主算法有异曲同工之妙……看起来卵用都没有，实际上可以帮你每个点平均优化200ms（可怕） 主要操作：把查询区间的排序函数 int cmp(query a, query b) { return belong[a.l] == belong[b.l] ? a.r &lt; b.r : belong[a.l] &lt; belong[b.l]; } 二话不说，直接删掉，换成 int cmp(query a, query b) { return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r); } 也就是说，对于左端点在同一奇数块的区间，右端点按升序排列，反之降序。这个东西也是看着没用，但实际效果显著。 它的主要原理便是右指针跳完奇数块往回跳时在同一个方向能顺路把偶数块跳完，然后跳完这个偶数块又能顺带把下一个奇数块跳完。理论上主算法运行时间减半，实际情况有所偏差。（不过能优化得很爽就对了） 3、移动指针的常数压缩 （仍然是来自原博客） 我们可以根据运算优先级的知识，把这个： void add(int pos) { if(!cnt[aa[pos]]) ++now; ++cnt[aa[pos]]; } void del(int pos) { --cnt[aa[pos]]; if(!cnt[aa[pos]]) --now; } 和这个： while(l &lt; ql) del(l++); while(l &gt; ql) add(--l); while(r &lt; qr) add(++r); while(r &gt; qr) del(r--); 硬生生压缩成这个： while(l &lt; ql) now -= !--cnt[aa[l++]]; while(l &gt; ql) now += !cnt[aa[--l]]++; while(r &lt; qr) now += !cnt[aa[++r]]++; while(r &gt; qr) now -= !--cnt[aa[r--]]; 能优化将近200ms（怎么又是这个数字） 而且这个优化看上去满满的不好搞，但实际上很有用。不过用它来优化千万要建立在熟练的基础上，不然会大大增强调试难度，不如不用。 4.手写快读、快输 （还是来自原博客） 大多数莫队题的输入输出量还是很大的……I/O优化与否，运行时间差异也很大。而且值得注意的是莫队经典题中基本没有输入输出负数的情况，不考虑负数又能优化一点小小的常数。 我们来写（抄）一下代码吧！（依然是来自原博客） #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; using namespace std; #define maxn 1010000 #define maxb 1010 int aa[maxn], cnt[maxn], belong[maxn]; int n, m, size, bnum, now, ans[maxn]; struct query { int l, r, id; } q[maxn]; int cmp(query a, query b) { return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r); } #define isdigit(x) ((x) &gt;= '0' &amp;&amp; (x) &lt;= '9') int read() { int res = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar(); return res; } void printi(int x) { if(x / 10) printi(x / 10); putchar(x % 10 + '0'); } int main() { scanf(&quot;%d&quot;, &amp;n); size = sqrt(n); bnum = ceil((double)n / size); for(int i = 1; i &lt;= bnum; ++i) for(int j = (i - 1) * size + 1; j &lt;= i * size; ++j) { belong[j] = i; } for(int i = 1; i &lt;= n; ++i) aa[i] = read(); m = read(); for(int i = 1; i &lt;= m; ++i) { q[i].l = read(), q[i].r = read(); q[i].id = i; } sort(q + 1, q + m + 1, cmp); int l = 1, r = 0; for(int i = 1; i &lt;= m; ++i) { int ql = q[i].l, qr = q[i].r; while(l &lt; ql) now -= !--cnt[aa[l++]]; while(l &gt; ql) now += !cnt[aa[--l]]++; while(r &lt; qr) now += !cnt[aa[++r]]++; while(r &gt; qr) now -= !--cnt[aa[r--]]; ans[q[i].id] = now; } for(int i = 1; i &lt;= m; ++i) printi(ans[i]), putchar('\\n'); return 0; } ","link":"https://david-h-devs.github.io/post/mo-dui/"},{"title":"二叉树","content":"（由于Gitalk暂时配置很麻烦，所以我等他配置好之后我在用吧！） 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 一棵深度为k，且有2k−12^k-12k−1个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。具有n个结点的完全二叉树的深度为floor(log⁡2n)+1\\mathrm{floor}(\\log 2n)+1floor(log2n)+1。深度为k的完全二叉树，至少有2k−12^{k-1}2k−1个叶子结点，至多有2k−12^k-12k−1个结点。 二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态： 空二叉树； 只有一个根节点的二叉树； 只有左子树； 只有右子树； 完全二叉树。 注意：二叉树不是树 我们来简要的写写二叉树的代码（例如去重搜索）： #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10; struct Node { int val, lc, rc, w; } T[N]; int n, cnt = 1, a[N]; void ins(int o, int v) { if (!(T[o].val)) { T[o].val = v; T[o].w++; return; } if (T[o].val == v) { T[o].w++; return; } if (v &lt; T[o].val) { if (!(T[o].lc)) T[o].lc = ++cnt; ins(T[o].lc, v); } if (v &gt; T[o].val) { if (!T[o].rc) T[o].rc = ++cnt; ins(T[o].rc, v); } } void dfs(int o) { if (!T[o].val) return; if (T[o].lc) dfs(T[o].lc); printf(&quot;%d &quot;, T[o].val); if (T[o].rc) dfs(T[o].rc); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i); for (int i = 1; i &lt;= n; i++) { ins(1, a[i]); } dfs(1); return 0; } ","link":"https://david-h-devs.github.io/post/xian-duan-shu/"},{"title":"新建博客撒花","content":"在3月7日（确切的来说几天前就建好了，但这次是正式版），我的博客建成了！ 这要感谢搭建Gridea的工程师们与我的朋友LewisLi（这是他的博客）。 总而言之，我的小博客总算建好了！以后还会陆续加一些东西，比如2D小人这类的qwq。 都要加油啊！ 中国总是被他们最勇敢的人保护得很好。 ","link":"https://david-h-devs.github.io/post/xin-jian-bo-ke-sa-hua/"}]}